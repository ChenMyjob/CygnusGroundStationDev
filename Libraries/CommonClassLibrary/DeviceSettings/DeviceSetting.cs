///////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2013-2015 Laszlo Arvai. All rights reserved.
//
// This library is free software; you can redistribute it and/or modify it 
// under the terms of the GNU Lesser General Public License as published
// by the Free Software Foundation; either version 2.1 of the License, 
// or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
// MA 02110-1301  USA
///////////////////////////////////////////////////////////////////////////////
// File description
// ----------------
// Device settings parser class
///////////////////////////////////////////////////////////////////////////////
using System;
using System.IO;
using System.IO.Compression;
using System.Text;
using System.Xml.XPath;

namespace CommonClassLibrary.DeviceSettings
{
	public class DeviceSettings : XMLParserBase
	{
		#region · Data members ·
		private StringBuilder m_header_file;
		private byte[] m_binary_buffer;
		private int m_binary_pos;
		#endregion

		#region · Properties ·
		/// <summary>
		/// Gets settngs root class
		/// </summary>
		public DeviceSettingsGroup DeviceSettingsRoot
		{
			get { return (DeviceSettingsGroup)m_root_class; }
		}
		#endregion

		#region · Overriden members ·

		/// <summary>
		/// Clears all data content of the class
		/// </summary>
		public override void Clear()
		{
			m_root_class = new DeviceSettingsGroup();
		}

		/// <summary>
		/// Parses Packet description
		/// </summary>
		/// <param name="in_element"></param>
		protected override void ParseElement(XPathNavigator in_element, TextReader in_xml_stream, object in_parent)
		{
			DeviceSettingsGroup parent = (DeviceSettingsGroup)in_parent;

			switch (in_element.Name)
			{
				case "Group":
					{
						DeviceSettingsGroup group = new DeviceSettingsGroup();

						group.ParseXML(in_element);

						ParseXMLChildNodes(in_element, in_xml_stream, group);

						parent.AddGroup(in_element, group);
					}
					break;

				case "String":
					{
						DeviceSettingValue value = new DeviceSettingValue(DeviceSettingValue.ValueType.StringValue);

						value.ParseXML(in_element);

						parent.AddValue(in_element, value);
					}
					break;

				case "Int":
					{
						DeviceSettingValue value = new DeviceSettingValue(DeviceSettingValue.ValueType.IntValue);

						value.ParseXML(in_element);

						parent.AddValue(in_element, value);
					}
					break;

				default:
					throw CreateXMLParseException(string.Format(DeviceSettingsStringConstants.ErrorInvalidElementType, in_element.Name), in_element);
			}

		}
		#endregion

		#region · Public members ·

		/// <summary>
		/// Creates all C files needs for the embedded software
		/// </summary>
		/// <param name="in_path">Full path of the original XML file</param>
		public void CreateCFiles(string in_path)
		{
			string xml_file_name = in_path;
			string xml_settings_xml_file_name;
			long xml_inline_length;
			string xml_file_name_without_extension;
			string xml_header_file_name;
			string define_name;
			string xml_settings_data_file_name;

			// generate file names
			xml_file_name_without_extension = Path.Combine(Path.GetDirectoryName(Path.GetFullPath(xml_file_name)), Path.GetFileNameWithoutExtension(xml_file_name));
			xml_header_file_name = xml_file_name_without_extension + ".h";
			xml_settings_xml_file_name = xml_file_name_without_extension + "_xml.inl";
			xml_settings_data_file_name = xml_file_name_without_extension + "_data.inl";

			// prepare header file
			m_header_file = new StringBuilder();

			m_header_file.AppendLine("///////////////////////////////////////////////////////////////////////////////");
			m_header_file.AppendLine("// This header file was generated by the SettingsParser");
			m_header_file.AppendLine("// at " + DateTime.Now.ToString());
			define_name = "__" + Path.GetFileNameWithoutExtension(xml_header_file_name.ToUpper()) + "_H";
			m_header_file.AppendLine("#ifndef " + define_name);
			m_header_file.AppendLine("#define " + define_name);
			m_header_file.AppendLine();

			// create GZIP-ed xml file
			using (MemoryStream xml_compressed_stream = new MemoryStream())
			{
				using (FileStream xml_file_stream = File.OpenRead(xml_file_name))
				{
					using (GZipStream compression_stream = new GZipStream(xml_compressed_stream, CompressionMode.Compress))
					{
						xml_file_stream.CopyTo(compression_stream);
					}
				}

				m_binary_buffer = xml_compressed_stream.ToArray();
				xml_inline_length = m_binary_buffer.Length;
			}

			WriteBinaryArrayIntoCArray(xml_settings_xml_file_name, m_binary_buffer);

			// traversing the tree and creating header declarations
			m_binary_pos = 0;
			GenerateHeaderDeclarations(m_root_class, "");

			// save binary length
			m_header_file.AppendLine();
			m_header_file.AppendLine("#define SETTINGS_XML_FILE_LENGTH " + xml_inline_length.ToString());
			m_header_file.AppendLine("#define SETTINGS_BINARY_FILE_LENGTH " + m_binary_pos.ToString());

			// save header file
			m_header_file.AppendLine();
			m_header_file.AppendLine("#endif");

			using (StreamWriter header_file = new StreamWriter(xml_header_file_name))
			{
				header_file.Write(m_header_file);
			}

			// save binary settings data (default data)
			m_binary_buffer = new byte[m_binary_pos];
			m_binary_pos = 0;

			GenerateBinarydata(m_root_class);

			WriteBinaryArrayIntoCArray(xml_settings_data_file_name, m_binary_buffer);
		}

		#endregion

		#region · Private functions ·

		/// <summary>
		/// Generates binary settings data
		/// </summary>
		/// <param name="in_settings"></param>
		private void GenerateBinarydata(object in_settings)
		{
			if (in_settings is DeviceSettingsGroup)
			{
				DeviceSettingsGroup settings = (DeviceSettingsGroup)in_settings;

				// process all subgroups
				foreach (DeviceSettingsGroup group in settings.Groups)
				{
					GenerateBinarydata(group);
				}

				// process all values
				foreach (DeviceSettingValue value in settings.Values)
				{
					GenerateBinarydata(value);
				}
			}
			else
			{
				if (in_settings is DeviceSettingValue)
				{
					DeviceSettingValue value = (DeviceSettingValue)in_settings;

					value.GetBinaryData().CopyTo(m_binary_buffer, m_binary_pos);

					m_binary_pos += value.GetBinaryLength();
				}
			}
		}

		/// <summary>
		/// Generates C header declarations
		/// </summary>
		/// <param name="in_settings"></param>
		/// <param name="in_path"></param>
		private void GenerateHeaderDeclarations(object in_settings, string in_path)
		{
			if (in_settings is DeviceSettingsGroup)
			{
				DeviceSettingsGroup settings = (DeviceSettingsGroup)in_settings;

				// generate path
				if (!string.IsNullOrEmpty(in_path))
					in_path += "_";
				in_path += settings.Name;

				// process all subgroups
				foreach (DeviceSettingsGroup group in settings.Groups)
				{
					GenerateHeaderDeclarations(group, in_path);
				}

				// process all values
				foreach (DeviceSettingValue value in settings.Values)
				{
					GenerateHeaderDeclarations(value, in_path);
				}
			}
			else
			{
				if (in_settings is DeviceSettingValue)
				{
					DeviceSettingValue value = (DeviceSettingValue)in_settings;
					string declaration = "#define " + in_path.ToUpper() + "_" + value.Name.ToUpper() + " " + m_binary_pos.ToString();

					m_header_file.AppendLine(declaration);

					m_binary_pos += value.GetBinaryLength();
				}
			}
		}

		/// <summary>
		/// Creates a C array from the given byte array
		/// </summary>
		/// <param name="in_file_name"></param>
		/// <param name="in_array"></param>
		private void WriteBinaryArrayIntoCArray(string in_file_name, byte[] in_array)
		{
			using (StreamWriter c_array_file = File.CreateText(in_file_name))
			{
				string line_buffer = "";
				int pos;

				for (pos = 0; pos < in_array.Length; pos++)
				{
					line_buffer += "0x" + in_array[pos].ToString("X2");

					if (((pos + 1) % 16) == 0 || pos == in_array.Length - 1)
					{
						if (pos < in_array.Length - 1)
							line_buffer += ",";

						c_array_file.WriteLine(line_buffer);

						line_buffer = "";
					}
					else
					{
						line_buffer += ", ";
					}
				}
			}
		}
		#endregion

	}
}
